============================= test session starts =============================
platform win32 -- Python 3.10.11, pytest-8.4.2, pluggy-1.6.0
rootdir: D:\Done,Toreview\SnS_App
plugins: anyio-4.11.0, cov-7.0.0, html-4.0.2, metadata-3.1.1, mock-3.15.1, ordering-0.6, rerunfailures-16.1, xdist-3.8.0, seleniumbase-4.44.15
collected 33 items

api\tests\test_api.py ...FF.                                             [ 18%]
api\tests\test_fourier.py F.F                                            [ 27%]
api\tests\test_period_detection.py ......                                [ 45%]
api\tests\test_symbolic.py ......F...F                                   [ 78%]
api\tests\test_system_analyzer.py ....F..                                [100%]

================================== FAILURES ===================================
________________________ test_analyze_system_endpoint _________________________

obj = -5.0*delta, include = None, exclude = None, by_alias = True
exclude_unset = False, exclude_defaults = False, exclude_none = False
custom_encoder = {}, sqlalchemy_safe = True

    def jsonable_encoder(
        obj: Annotated[
            Any,
            Doc(
                """
                The input object to convert to JSON.
                """
            ),
        ],
        include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `include` parameter, passed to Pydantic models to set the
                fields to include.
                """
            ),
        ] = None,
        exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `exclude` parameter, passed to Pydantic models to set the
                fields to exclude.
                """
            ),
        ] = None,
        by_alias: Annotated[
            bool,
            Doc(
                """
                Pydantic's `by_alias` parameter, passed to Pydantic models to define if
                the output should use the alias names (when provided) or the Python
                attribute names. In an API, if you set an alias, it's probably because you
                want to use it in the result, so you probably want to leave this set to
                `True`.
                """
            ),
        ] = True,
        exclude_unset: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_unset` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that were not explicitly
                set (and that only had their default values).
                """
            ),
        ] = False,
        exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that had the same default
                value, even when they were explicitly set.
                """
            ),
        ] = False,
        exclude_none: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_none` parameter, passed to Pydantic models to define
                if it should exclude from the output any fields that have a `None` value.
                """
            ),
        ] = False,
        custom_encoder: Annotated[
            Optional[Dict[Any, Callable[[Any], Any]]],
            Doc(
                """
                Pydantic's `custom_encoder` parameter, passed to Pydantic models to define
                a custom encoder.
                """
            ),
        ] = None,
        sqlalchemy_safe: Annotated[
            bool,
            Doc(
                """
                Exclude from the output any fields that start with the name `_sa`.
    
                This is mainly a hack for compatibility with SQLAlchemy objects, they
                store internal SQLAlchemy-specific state in attributes named with `_sa`,
                and those objects can't (and shouldn't be) serialized to JSON.
                """
            ),
        ] = True,
    ) -> Any:
        """
        Convert any object to something that can be encoded in JSON.
    
        This is used internally by FastAPI to make sure anything you return can be
        encoded as JSON before it is sent to the client.
    
        You can also use it yourself, for example to convert objects before saving them
        in a database that supports only JSON.
    
        Read more about it in the
        [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
        """
        custom_encoder = custom_encoder or {}
        if custom_encoder:
            if type(obj) in custom_encoder:
                return custom_encoder[type(obj)](obj)
            else:
                for encoder_type, encoder_instance in custom_encoder.items():
                    if isinstance(obj, encoder_type):
                        return encoder_instance(obj)
        if include is not None and not isinstance(include, (set, dict)):
            include = set(include)
        if exclude is not None and not isinstance(exclude, (set, dict)):
            exclude = set(exclude)
        if isinstance(obj, (BaseModel, may_v1.BaseModel)):
            # TODO: remove when deprecating Pydantic v1
            encoders: Dict[Any, Any] = {}
            if isinstance(obj, may_v1.BaseModel):
                encoders = getattr(obj.__config__, "json_encoders", {})  # type: ignore[attr-defined]
                if custom_encoder:
                    encoders = {**encoders, **custom_encoder}
            obj_dict = _model_dump(
                obj,
                mode="json",
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
            )
            if "__root__" in obj_dict:
                obj_dict = obj_dict["__root__"]
            return jsonable_encoder(
                obj_dict,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
                # TODO: remove when deprecating Pydantic v1
                custom_encoder=encoders,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if dataclasses.is_dataclass(obj):
            assert not isinstance(obj, type)
            obj_dict = dataclasses.asdict(obj)
            return jsonable_encoder(
                obj_dict,
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_defaults=exclude_defaults,
                exclude_none=exclude_none,
                custom_encoder=custom_encoder,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if isinstance(obj, Enum):
            return obj.value
        if isinstance(obj, PurePath):
            return str(obj)
        if isinstance(obj, (str, int, float, type(None))):
            return obj
        if _is_undefined(obj):
            return None
        if isinstance(obj, dict):
            encoded_dict = {}
            allowed_keys = set(obj.keys())
            if include is not None:
                allowed_keys &= set(include)
            if exclude is not None:
                allowed_keys -= set(exclude)
            for key, value in obj.items():
                if (
                    (
                        not sqlalchemy_safe
                        or (not isinstance(key, str))
                        or (not key.startswith("_sa"))
                    )
                    and (value is not None or not exclude_none)
                    and key in allowed_keys
                ):
                    encoded_key = jsonable_encoder(
                        key,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_value = jsonable_encoder(
                        value,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_dict[encoded_key] = encoded_value
            return encoded_dict
        if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):
            encoded_list = []
            for item in obj:
                encoded_list.append(
                    jsonable_encoder(
                        item,
                        include=include,
                        exclude=exclude,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_defaults=exclude_defaults,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                )
            return encoded_list
    
        if type(obj) in ENCODERS_BY_TYPE:
            return ENCODERS_BY_TYPE[type(obj)](obj)
        for encoder, classes_tuple in encoders_by_class_tuples.items():
            if isinstance(obj, classes_tuple):
                return encoder(obj)
    
        try:
>           data = dict(obj)
E           TypeError: 'Mul' object is not iterable

C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\encoders.py:337: TypeError

During handling of the above exception, another exception occurred:

obj = -5.0*delta, include = None, exclude = None, by_alias = True
exclude_unset = False, exclude_defaults = False, exclude_none = False
custom_encoder = {}, sqlalchemy_safe = True

    def jsonable_encoder(
        obj: Annotated[
            Any,
            Doc(
                """
                The input object to convert to JSON.
                """
            ),
        ],
        include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `include` parameter, passed to Pydantic models to set the
                fields to include.
                """
            ),
        ] = None,
        exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `exclude` parameter, passed to Pydantic models to set the
                fields to exclude.
                """
            ),
        ] = None,
        by_alias: Annotated[
            bool,
            Doc(
                """
                Pydantic's `by_alias` parameter, passed to Pydantic models to define if
                the output should use the alias names (when provided) or the Python
                attribute names. In an API, if you set an alias, it's probably because you
                want to use it in the result, so you probably want to leave this set to
                `True`.
                """
            ),
        ] = True,
        exclude_unset: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_unset` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that were not explicitly
                set (and that only had their default values).
                """
            ),
        ] = False,
        exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that had the same default
                value, even when they were explicitly set.
                """
            ),
        ] = False,
        exclude_none: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_none` parameter, passed to Pydantic models to define
                if it should exclude from the output any fields that have a `None` value.
                """
            ),
        ] = False,
        custom_encoder: Annotated[
            Optional[Dict[Any, Callable[[Any], Any]]],
            Doc(
                """
                Pydantic's `custom_encoder` parameter, passed to Pydantic models to define
                a custom encoder.
                """
            ),
        ] = None,
        sqlalchemy_safe: Annotated[
            bool,
            Doc(
                """
                Exclude from the output any fields that start with the name `_sa`.
    
                This is mainly a hack for compatibility with SQLAlchemy objects, they
                store internal SQLAlchemy-specific state in attributes named with `_sa`,
                and those objects can't (and shouldn't be) serialized to JSON.
                """
            ),
        ] = True,
    ) -> Any:
        """
        Convert any object to something that can be encoded in JSON.
    
        This is used internally by FastAPI to make sure anything you return can be
        encoded as JSON before it is sent to the client.
    
        You can also use it yourself, for example to convert objects before saving them
        in a database that supports only JSON.
    
        Read more about it in the
        [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
        """
        custom_encoder = custom_encoder or {}
        if custom_encoder:
            if type(obj) in custom_encoder:
                return custom_encoder[type(obj)](obj)
            else:
                for encoder_type, encoder_instance in custom_encoder.items():
                    if isinstance(obj, encoder_type):
                        return encoder_instance(obj)
        if include is not None and not isinstance(include, (set, dict)):
            include = set(include)
        if exclude is not None and not isinstance(exclude, (set, dict)):
            exclude = set(exclude)
        if isinstance(obj, (BaseModel, may_v1.BaseModel)):
            # TODO: remove when deprecating Pydantic v1
            encoders: Dict[Any, Any] = {}
            if isinstance(obj, may_v1.BaseModel):
                encoders = getattr(obj.__config__, "json_encoders", {})  # type: ignore[attr-defined]
                if custom_encoder:
                    encoders = {**encoders, **custom_encoder}
            obj_dict = _model_dump(
                obj,
                mode="json",
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
            )
            if "__root__" in obj_dict:
                obj_dict = obj_dict["__root__"]
            return jsonable_encoder(
                obj_dict,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
                # TODO: remove when deprecating Pydantic v1
                custom_encoder=encoders,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if dataclasses.is_dataclass(obj):
            assert not isinstance(obj, type)
            obj_dict = dataclasses.asdict(obj)
            return jsonable_encoder(
                obj_dict,
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_defaults=exclude_defaults,
                exclude_none=exclude_none,
                custom_encoder=custom_encoder,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if isinstance(obj, Enum):
            return obj.value
        if isinstance(obj, PurePath):
            return str(obj)
        if isinstance(obj, (str, int, float, type(None))):
            return obj
        if _is_undefined(obj):
            return None
        if isinstance(obj, dict):
            encoded_dict = {}
            allowed_keys = set(obj.keys())
            if include is not None:
                allowed_keys &= set(include)
            if exclude is not None:
                allowed_keys -= set(exclude)
            for key, value in obj.items():
                if (
                    (
                        not sqlalchemy_safe
                        or (not isinstance(key, str))
                        or (not key.startswith("_sa"))
                    )
                    and (value is not None or not exclude_none)
                    and key in allowed_keys
                ):
                    encoded_key = jsonable_encoder(
                        key,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_value = jsonable_encoder(
                        value,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_dict[encoded_key] = encoded_value
            return encoded_dict
        if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):
            encoded_list = []
            for item in obj:
                encoded_list.append(
                    jsonable_encoder(
                        item,
                        include=include,
                        exclude=exclude,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_defaults=exclude_defaults,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                )
            return encoded_list
    
        if type(obj) in ENCODERS_BY_TYPE:
            return ENCODERS_BY_TYPE[type(obj)](obj)
        for encoder, classes_tuple in encoders_by_class_tuples.items():
            if isinstance(obj, classes_tuple):
                return encoder(obj)
    
        try:
            data = dict(obj)
        except Exception as e:
            errors: List[Exception] = []
            errors.append(e)
            try:
>               data = vars(obj)
E               TypeError: vars() argument must have __dict__ attribute

C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\encoders.py:342: TypeError

The above exception was the direct cause of the following exception:

    def test_analyze_system_endpoint():
        payload = {
            "equation": "x(t)",
            "domain": "continuous"
        }
>       response = client.post("/analyze_system", json=payload)

api\tests\test_api.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\testclient.py:546: in post
    return super().post(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\httpx\_client.py:1144: in post
    return self.request(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\testclient.py:445: in request
    return super().request(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\testclient.py:348: in handle_request
    raise exc
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\testclient.py:345: in handle_request
    portal.call(self.app, scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py:458: in result
    return self.__get_result()
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\concurrent\futures\_base.py:403: in __get_result
    raise self._exception
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\applications.py:1139: in __call__
    await super().__call__(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\applications.py:107: in __call__
    await self.middleware_stack(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\routing.py:120: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\routing.py:106: in app
    response = await f(request)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\routing.py:452: in app
    content = await serialize_response(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\routing.py:305: in serialize_response
    return jsonable_encoder(response_content)
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\encoders.py:302: in jsonable_encoder
    encoded_value = jsonable_encoder(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\encoders.py:302: in jsonable_encoder
    encoded_value = jsonable_encoder(
C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\encoders.py:316: in jsonable_encoder
    jsonable_encoder(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

obj = -5.0*delta, include = None, exclude = None, by_alias = True
exclude_unset = False, exclude_defaults = False, exclude_none = False
custom_encoder = {}, sqlalchemy_safe = True

    def jsonable_encoder(
        obj: Annotated[
            Any,
            Doc(
                """
                The input object to convert to JSON.
                """
            ),
        ],
        include: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `include` parameter, passed to Pydantic models to set the
                fields to include.
                """
            ),
        ] = None,
        exclude: Annotated[
            Optional[IncEx],
            Doc(
                """
                Pydantic's `exclude` parameter, passed to Pydantic models to set the
                fields to exclude.
                """
            ),
        ] = None,
        by_alias: Annotated[
            bool,
            Doc(
                """
                Pydantic's `by_alias` parameter, passed to Pydantic models to define if
                the output should use the alias names (when provided) or the Python
                attribute names. In an API, if you set an alias, it's probably because you
                want to use it in the result, so you probably want to leave this set to
                `True`.
                """
            ),
        ] = True,
        exclude_unset: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_unset` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that were not explicitly
                set (and that only had their default values).
                """
            ),
        ] = False,
        exclude_defaults: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_defaults` parameter, passed to Pydantic models to define
                if it should exclude from the output the fields that had the same default
                value, even when they were explicitly set.
                """
            ),
        ] = False,
        exclude_none: Annotated[
            bool,
            Doc(
                """
                Pydantic's `exclude_none` parameter, passed to Pydantic models to define
                if it should exclude from the output any fields that have a `None` value.
                """
            ),
        ] = False,
        custom_encoder: Annotated[
            Optional[Dict[Any, Callable[[Any], Any]]],
            Doc(
                """
                Pydantic's `custom_encoder` parameter, passed to Pydantic models to define
                a custom encoder.
                """
            ),
        ] = None,
        sqlalchemy_safe: Annotated[
            bool,
            Doc(
                """
                Exclude from the output any fields that start with the name `_sa`.
    
                This is mainly a hack for compatibility with SQLAlchemy objects, they
                store internal SQLAlchemy-specific state in attributes named with `_sa`,
                and those objects can't (and shouldn't be) serialized to JSON.
                """
            ),
        ] = True,
    ) -> Any:
        """
        Convert any object to something that can be encoded in JSON.
    
        This is used internally by FastAPI to make sure anything you return can be
        encoded as JSON before it is sent to the client.
    
        You can also use it yourself, for example to convert objects before saving them
        in a database that supports only JSON.
    
        Read more about it in the
        [FastAPI docs for JSON Compatible Encoder](https://fastapi.tiangolo.com/tutorial/encoder/).
        """
        custom_encoder = custom_encoder or {}
        if custom_encoder:
            if type(obj) in custom_encoder:
                return custom_encoder[type(obj)](obj)
            else:
                for encoder_type, encoder_instance in custom_encoder.items():
                    if isinstance(obj, encoder_type):
                        return encoder_instance(obj)
        if include is not None and not isinstance(include, (set, dict)):
            include = set(include)
        if exclude is not None and not isinstance(exclude, (set, dict)):
            exclude = set(exclude)
        if isinstance(obj, (BaseModel, may_v1.BaseModel)):
            # TODO: remove when deprecating Pydantic v1
            encoders: Dict[Any, Any] = {}
            if isinstance(obj, may_v1.BaseModel):
                encoders = getattr(obj.__config__, "json_encoders", {})  # type: ignore[attr-defined]
                if custom_encoder:
                    encoders = {**encoders, **custom_encoder}
            obj_dict = _model_dump(
                obj,
                mode="json",
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
            )
            if "__root__" in obj_dict:
                obj_dict = obj_dict["__root__"]
            return jsonable_encoder(
                obj_dict,
                exclude_none=exclude_none,
                exclude_defaults=exclude_defaults,
                # TODO: remove when deprecating Pydantic v1
                custom_encoder=encoders,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if dataclasses.is_dataclass(obj):
            assert not isinstance(obj, type)
            obj_dict = dataclasses.asdict(obj)
            return jsonable_encoder(
                obj_dict,
                include=include,
                exclude=exclude,
                by_alias=by_alias,
                exclude_unset=exclude_unset,
                exclude_defaults=exclude_defaults,
                exclude_none=exclude_none,
                custom_encoder=custom_encoder,
                sqlalchemy_safe=sqlalchemy_safe,
            )
        if isinstance(obj, Enum):
            return obj.value
        if isinstance(obj, PurePath):
            return str(obj)
        if isinstance(obj, (str, int, float, type(None))):
            return obj
        if _is_undefined(obj):
            return None
        if isinstance(obj, dict):
            encoded_dict = {}
            allowed_keys = set(obj.keys())
            if include is not None:
                allowed_keys &= set(include)
            if exclude is not None:
                allowed_keys -= set(exclude)
            for key, value in obj.items():
                if (
                    (
                        not sqlalchemy_safe
                        or (not isinstance(key, str))
                        or (not key.startswith("_sa"))
                    )
                    and (value is not None or not exclude_none)
                    and key in allowed_keys
                ):
                    encoded_key = jsonable_encoder(
                        key,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_value = jsonable_encoder(
                        value,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                    encoded_dict[encoded_key] = encoded_value
            return encoded_dict
        if isinstance(obj, (list, set, frozenset, GeneratorType, tuple, deque)):
            encoded_list = []
            for item in obj:
                encoded_list.append(
                    jsonable_encoder(
                        item,
                        include=include,
                        exclude=exclude,
                        by_alias=by_alias,
                        exclude_unset=exclude_unset,
                        exclude_defaults=exclude_defaults,
                        exclude_none=exclude_none,
                        custom_encoder=custom_encoder,
                        sqlalchemy_safe=sqlalchemy_safe,
                    )
                )
            return encoded_list
    
        if type(obj) in ENCODERS_BY_TYPE:
            return ENCODERS_BY_TYPE[type(obj)](obj)
        for encoder, classes_tuple in encoders_by_class_tuples.items():
            if isinstance(obj, classes_tuple):
                return encoder(obj)
    
        try:
            data = dict(obj)
        except Exception as e:
            errors: List[Exception] = []
            errors.append(e)
            try:
                data = vars(obj)
            except Exception as e:
                errors.append(e)
>               raise ValueError(errors) from e
E               ValueError: [TypeError("'Mul' object is not iterable"), TypeError('vars() argument must have __dict__ attribute')]

C:\Users\DELL\AppData\Local\Programs\Python\Python310\lib\site-packages\fastapi\encoders.py:345: ValueError
---------------------------- Captured stdout call -----------------------------
[generate_plot_data] Input: delta(t), Domain: continuous
[analyze_system] Output Expr: delta*t
[generate_plot_data] Input: delta*t, Domain: continuous
[generate_plot_data] Input: d(t), Domain: continuous
_________________________ test_detect_period_endpoint _________________________

    def test_detect_period_endpoint():
        payload = {
            "expression": "sin(t)",
            "domain": "continuous"
        }
        response = client.post("/fourier/detect-period", json=payload)
        assert response.status_code == 200
        assert response.json()["period"] is not None
>       assert " Detected period" in response.json()["message"]
E       AssertionError: assert ' Detected period' in 'Detected period T = 6.2832'

api\tests\test_api.py:54: AssertionError
_____________________________ test_calculate_ctfs _____________________________

    def test_calculate_ctfs():
        # Test CTFS for sin(t) with T = 2*pi
        # x(t) = sin(t) = (e^jt - e^-jt)/(2j)
        # a_1 = 1/(2j) = -0.5j, a_-1 = -1/(2j) = 0.5j
        coeffs = calculate_ctfs("sin(t)", float(2*np.pi), k_min=-2, k_max=2)
    
        assert len(coeffs) == 5 # -2, -1, 0, 1, 2
    
        # k = 1
        a1 = next(c for c in coeffs if c["k"] == 1)
>       assert np.isclose(a1["magnitude"], 0.5)
E       assert False
E        +  where False = <function isclose at 0x000002257F7A6BF0>(219695807535287.4, 0.5)
E        +    where <function isclose at 0x000002257F7A6BF0> = np.isclose

api\tests\test_fourier.py:15: AssertionError
_________________________ test_calculate_inverse_ctfs _________________________

    def test_calculate_inverse_ctfs():
        # Test synthesis from ak = 1 for k=0 and 0 otherwise
        # x(t) = 1
        xt_expr = calculate_inverse_ctfs("1", 6.28, k_min=0, k_max=0)
        assert "1" in str(xt_expr)
    
        # Test synthesis from ak = (1 if k==1 else 0)
        # x(t) = exp(j*w0*t)
        xt_expr = calculate_inverse_ctfs("k", 6.28, k_min=1, k_max=1)
        assert "exp" in str(xt_expr)
>       assert "I*t" in str(xt_expr)
E       AssertionError: assert 'I*t' in 'exp(0.318471337579618*I*pi*t)'
E        +  where 'exp(0.318471337579618*I*pi*t)' = str(exp(0.318471337579618*I*pi*t))

api\tests\test_fourier.py:47: AssertionError
_________________________ test_generate_plot_data_dt __________________________

    def test_generate_plot_data_dt():
        x, y = generate_plot_data("u[n]", -5, 5, domain="discrete")
        # n = -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 -> 11 points
        assert len(x) == 11
>       assert y[5] == 1.0 # u[0]
E       assert 0.0 == 1.0

api\tests\test_symbolic.py:65: AssertionError
---------------------------- Captured stdout call -----------------------------
[generate_plot_data] Input: u[n], Domain: discrete
______________________ test_evaluate_frequency_response _______________________

    def test_evaluate_frequency_response():
        resp = evaluate_frequency_response("1/(1 + j*w)", w_min=-5, w_max=5)
        assert "magnitude" in resp
        assert "phase" in resp
        assert len(resp["magnitude"]["x"]) == 400
        # At w=0, 1/(1+0) = 1
>       assert np.isclose(resp["magnitude"]["y"][200], 1.0)
E       assert False
E        +  where False = <function isclose at 0x000002257F7A6BF0>(0.990632713959711, 1.0)
E        +    where <function isclose at 0x000002257F7A6BF0> = np.isclose

api\tests\test_symbolic.py:91: AssertionError
---------------------------- Captured stdout call -----------------------------
[evaluate_frequency_response] Original: 1/(1 + j*w)
[evaluate_frequency_response] Cleaned: 1/(1 + 11j*w)
[evaluate_frequency_response] Evaluated 400 points
[evaluate_frequency_response] Sample mag values: [0.01817881 0.01827036 0.01836284 0.01845626 0.01855063]
_______________________________ test_stability ________________________________

    def test_stability():
        # Stable
>       assert check_stability("exp(-t)*u(t)", "continuous")["status"] == "yes"
E       AssertionError: assert 'unknown' == 'yes'
E         
E         - yes
E         + unknown

api\tests\test_system_analyzer.py:43: AssertionError
=========================== short test summary info ===========================
FAILED api/tests/test_api.py::test_analyze_system_endpoint - ValueError: [Typ...
FAILED api/tests/test_api.py::test_detect_period_endpoint - AssertionError: a...
FAILED api/tests/test_fourier.py::test_calculate_ctfs - assert False
FAILED api/tests/test_fourier.py::test_calculate_inverse_ctfs - AssertionErro...
FAILED api/tests/test_symbolic.py::test_generate_plot_data_dt - assert 0.0 ==...
FAILED api/tests/test_symbolic.py::test_evaluate_frequency_response - assert ...
FAILED api/tests/test_system_analyzer.py::test_stability - AssertionError: as...
======================== 7 failed, 26 passed in 6.69s =========================
